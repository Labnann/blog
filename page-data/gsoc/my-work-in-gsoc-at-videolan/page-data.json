{"componentChunkName":"component---src-templates-blog-post-js","path":"/gsoc/my-work-in-gsoc-at-videolan/","result":{"data":{"site":{"siteMetadata":{"title":"Labnan's Blog"}},"markdownRemark":{"id":"e8efab9e-25aa-522b-aadb-0cda46cf09b7","excerpt":"My work at Google Summer of Code, to simply explain is: enabling dynamic\nloading for wasm32-unknown-emscripten. To understand it, we need to delve\ninto how VLCâ€¦","html":"<p>My work at Google Summer of Code, to simply explain is: enabling dynamic\nloading for wasm32-unknown-emscripten. To understand it, we need to delve\ninto how VLC's plugins are loaded.</p>\n<p>All vlc modules are declared in the source code using the series of macro\nthat starts with vlc_module_begin() and ends with vlc_module_end().</p>\n<p>For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">vlc_module_begin()\n    set_shortname(N_(\"hello\"))\n    set_description(N_(\"Hello World Module\"))\n    set_capability(\"dummy\", 0)\n    set_callbacks(Open, Close)\nvlc_module_end()</code></pre></div>\n<p>In this example callbacks we define how the module is going to be initiated.\nWe give it name and capability (category) and how the module will be\nclosed.</p>\n<p>If we see the definition vlc_module_begin macro, we will find that\nit is expanded into a function named vlc_entry which takes a callback\nvlc_set and opaque as input.</p>\n<p>Now let us look into bank.c. In case of shared loading, in module_InitDynamic\nwe find that the function is loaded from a dynamic plugin file using dlopen.\nThen using dlsym, the vlc_entry function is searched and resolved.\nIn case of static module, there is a global list of static entries\nnamed vlc_static_modules.</p>\n<p>In both cases, upon finding the entry function, which we know takes a callback,\nit is passed into the vlc_plugin_describe function. From here,\nthe entry function is called with the callback vlc_plugin_desc_cb\nand opaque. Where opaque, in this context is a newly initiated\nvlc_plugin_t instance.</p>\n<p>If we look into vlc_plugin_desc_cb we can see that there is a switch\nstatement, that switches a property and based on the property it runs\nsome code.</p>\n<p>So, the entry function now has the ability to use the callback vlc_set\nto invoke vlc_plugin_desc_cb and do various things like this:</p>\n<p>vlc_set (opaque, NULL, VLC_MODULE_CREATE)</p>\n<p>To simplify this call, there are helper functions like vlc_plugin_set,\nvlc_module_set, vlc_config_set. But they all in the end invokes this.\nThis way the plugin describes itself and all its capabilities until\nit hits the vlc_module_end ie. the return statement.</p>\n<p>But where is the point that decides whether to load with dynamic module\nor shared module? To answer this we have to look into the function\nmodule_loadPlugins. This function itself is called from libvlc_new\nat some point which is exposed to the front end. During compilation\nthere is a configuration variable named HAVE_DYNAMIC_PLUGINS.</p>\n<p>My work is based on this, to get \"HAVE_DYNAMIC_PLUGINS\" enabled for\nwasm32-emscripten. Which will cause module_loadPlugins to call\nAllocateAllPlugins which recursively looking for the modules in the\ngiven path passed via environment variables or other methods from the\nfront end.</p>\n<p>Now to enable this I had to make changes into libtool to allow\nit inform it about how to \"compile\" shared modules.</p>\n<p>While working on this, I came accross an interesting problem. You see\nVLC uses GNU Autotools to create their compilation script, like most\nother C/C++ projects. The compilation process is simple, if all\ndependencies are installed.</p>\n<p>First you bootstrap with ./bootstrap\nThen you configure, with ./configure [--enable-params] [--disable-params]\n[other params]\nAnd finally you compile, using GNU/Make, with the command 'make'.</p>\n<p>In the configure step, among various enable/disable parameters, there\nis one parameter called \"shared\". This allows the modules to be compiled\nas dynamic libraries, making them dynamic linkable.</p>\n<p>So, to enable dynamic linking for wasm32-unknown-emscripten I had to just\ndo this one thing: add --enable-shared to the configure parameters,\nright?</p>\n<p>Wrong! Turns out even if we use --enable-shared in case of wasm32-unknown-emscripten\nit does static compilation! I first realized this when I tried\n--enable-vlc with --enable-shared just to see how it turns out. And\nthe configuration fails with the error:\n\"VLC is based on plugins. Shared libraries cannot be disabled.\"</p>\n<p>Something is wrong! This is not supposed to happen, I have tried with\nx86_64-linux host, and it works perfectly, then why not in case of\nemscripten? For some reason, shared libraries can not be enabled!\nTime for some investigation.</p>\n<p>So what is wasm32-unknown-emscripten?\nFor that, you have to know what cross compilation triplet is. Briefly saying,\nit is <Architecture>-<Vendor>-<Operating System>, so here wasm32 is the\narchitecture here, emscripten is the Operating System taken to be running\non the browser. VLC.js is basically vlc media player ported to web assembly,\nrunning with Emscripten in browser, hence we use this.</p>\n<p>So, the first thing I did was enable building of vlc binaries,  with\n--enable-vlc, as vlc binaries can not be built without dynamic loading\nenabled. There has to be a check there, that makes sure that shared\nmodules are enabled.  Opening the configure script and searching for\n\"VLC is based on plugins\", we indeed find the condition there:</p>\n<p>if test \"${enable_shared}\" = \"no\" -a \"${enable_vlc}\" != \"no\"</p>\n<p>So, something must have caused enable_shared to be no, But what is it?</p>\n<p>Something must have assigned enable_shared to be no, so let's search\nfor \"enable_shared=no\", and just few lines before the above line, we\nfind that:</p>\n<p>test no = \"$can_build_shared\" &#x26;&#x26; enable_shared=no</p>\n<p>So, the value of enable_shared came from can_build_shared, so now we\nsearch for \"can_build_shared=no\" to find out that its value came from\nthe variable dynamic_linker. And it turns out the value of dynamic_linker\nis pre-assigned based on host_os. For example, if host_os is android,\ndynamic linker is \"Android linker\" and so on. There seemed to be only\none purpose of this variable, that is to indicate whether a dynamic linker\nexists for that particular host_os. Which does not exist for the host_os\nI am targetting, \"emscripten\".</p>\n<p>But the name, \"Android linker\" for android has to come from somewhere.\nThe configure script itself is generated from various configure.am files\nwhen running the bootstrap script as mentioned earlier. So, I make a quick search:</p>\n<p>git grep -r \"Android linker\"</p>\n<p>Only to find nothing. So this value does not exist in the repository as\na configuration file or anything, rather the value came from outside the\nrepository. My mentor Alexandre Janniaux was very helpful to point out\nthat the value comes from libtool, and what we can do at this point is to\nhack libtool and add dynamic_linker for emscripten at libtool/m4/libtool.m4\nand use that custom libtool.</p>\n<p>And in libtool.m4 there it was, the \"Android linker\" for the host\nlinux*android. Taking inspiration from how android section was implemented,\nwe added a new host_os named emscripten, with dynamic_linker to be\n\"Emscripten linker\", and bingo! After rebootstrapping with the new libtool\nthe configuration script ran successfully without switching to static mode\nsilently.</p>\n<p>So, what is libttool?\nLibtool is a generic library support script that hides the complexity of\nusing shared libraries behind a consistent, portable interface. Different\ncompilers take different flags, commands or approaches to compile shared\nlibraries. Therefore compiler front end becomes inconsistent. Which in terms,\nforces us to use too many unnecessary conditionals in Makefiles. To fix\nthis issue, Libtool was developed, it handles the differences internally\nwhile giving a consistent front end that we can use for the Makefiles,\nenabling us to compile for any other targets whenever needed.</p>\n<p>Later, we configured emscripten host in libtool to make compilation\ncompatible with various features in Emscripten compiler that is different\nfrom Clang or GCC.</p>\n<p>By now we already know where to change for emscripten host. So later is\npretty straightforward. That is to understand what is needed for successful\ncompilation and configure libtool's source accordingly.\nLook around the source! There are examples everywhere.\nStill we need to make sure what we need and carefully enable the required\nfeatures corrosponding to the compiler.</p>\n<p>Well, since my shared compilation is not being forcefully disabled,\nnow, I can try to figure out from the error and warning messages which\ncompiler options should be removed and which are to be added.</p>\n<p>For example, at this stage, configuring with --enable-shared and\ncompiling it gives the warning:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">emcc: warning: linking a library with `-shared` will emit a static \nobject file. This is a form of emulation to support existing build \nsystems.  If you want to build a runtime shared library use the \nSIDE_MODULE setting. [-Wemcc]</code></pre></div>\n<p>Now from the documentation of emscripten we do find out that SIDE_MODULE\nis emscripten's way of compiling a code as shared module, as opposed\nto -shared. So, we have to use that instead. But how do we add this\nto libtool?</p>\n<p>For this we use the LT_TAGVAR method to modify archive_cmds. This simply\nedits the part of libtool that creates dynamic library archives to answer:\n\"Which parameters will I run to create the archive?\"</p>\n<p>.. m4 ::\n_LT_TAGVAR(archive_cmds, $1)='-s SIDE_MODULE=1'</p>\n<p>Libtool has default way of naming each library archives and shared\nobjects, which include, name, relese and extension. If we want we\ncan change this default behavior by changing library_name_spec and\nsoname_spec.</p>\n<p>.. m4 ::\nlibrary_names_spec='$libname$release$shared_ext'\nsoname_spec='$libname$release$shared_ext'</p>\n<p>We can also tell libtool which command parameter is\nnecessary for position independent code setting <code class=\"language-text\">_LT_COMPILER_PIC</code>. For\nour purpose, we  needed <code class=\"language-text\">-fPIC</code>. However, now, you can try inspecting\nthis variable for Windows section! As we know Windows does not use\nposition independent code, but uses a very different method to achieve\nshared loading. That's the beauty of libtool! With all these\ncomplexities taken care of here, we do not need to worry about  it in\ncompile time. With this we can easily configure cross compilation for\nall platforms with a single build script!</p>\n<p>Finally, at your build path (The path from where you run your configure\nscript) there is an interesting file named <code class=\"language-text\">config.status</code>.\nThis file is created when you run the configure script. Observing this\nfile, you can find some interesting keys. Keys like: soname_spec,\narchive_cmds, lt_prog_compiler_pic. Sounds familiar right? We just\nworked with these keys above, in libtool.m4!</p>\n<p>This file helped me a lot while debugging libtool.m4, hope it helps\nyou as well ;).</p>\n<p>With the libtool.m4 ready for emscripten compilation, we can now finally\ninitiate compilation. Libtool will configure itself and put necessary\nflags for us. At this point everything compiled successfully, till the\ncompilation of binaries. Then this error shows up:</p>\n<p>.. log ::\nerror: undefined symbol: libvlc_new (referenced by\ntop-level compiled C/C++ code)\nwarning: _libvlc_new may need to be added to\nEXPORTED_FUNCTIONS if it arrives from a system library<br>\nHere I just showed the error for libvlc_new function only. But this error\noccurs in case of all the functions that are exposed to the front end.</p>\n<p>But why does it occur? Well during compilation of shared modules, some\ncompilers demand another flag that tells which functions to be exported\ni.e. can be seen by the user. Different compiler implements it differently,\nemscripten has its own way of doing this as well.</p>\n<p>In case of  We can use -s EXPORTED_FUNCTIONS to provide the function\nnames. Like this:\n<code class=\"language-text\">emcc code.c -s EXPORTED_FUNCTIONS=_function1,_function2,_function3</code></p>\n<p>We can provide them through  a file as well:\n<code class=\"language-text\">-s EXPORTED_FUNCTIONS=@path/to/file.sym</code></p>\n<p>The file has to be a text file. Within this: functions are provided\nlike this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">_function1\n_function2\n_function3</code></pre></div>\n<p>Doing so will expose function1, function2, function3 from code.c.</p>\n<p>Notice that, the actual function name is function1, but while when exporting,\nwe use the name _function1.</p>\n<p>Likewise, different compiler was implemented with different standards.\nSome compilers do not even take file name, some compilers do not add _\nbefore their function names. Some compilers do not even need to export\nfunctions.</p>\n<p>Now libtool handles this very interestingly. It takes the symbol file\npath as input with --export-symbols option. In the backend in libtool.m4\nwe can catch this file path in the export_symbol variable.\nThen the commands saved at archive_expsym_cmds is used to compile the file.</p>\n<p>Conventionally, this file contains function list like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function1\nfunction2\nfunction3</code></pre></div>\n<p>That looks great! But there is a big problem. Emscripten takes shared\nfunction input prefixing with _. But conventionally we do not have that!</p>\n<p>To solve this I took the following steps:</p>\n<ul>\n<li>Take the input file.</li>\n<li>Add _ before each line.</li>\n<li>Save it to another file.</li>\n<li>Use that file.</li>\n</ul>\n<p>But how to do all these while assigning it to\n<code class=\"language-text\">_LT_TAGVAR(archive_expsym_cmds, $1)</code>?</p>\n<p>Turns out _LT_TAGVAR has a cool way to instruct it to run a command\nwhile assigning a string. You can use it like this:</p>\n<p><code class=\"language-text\">\"Your Command Here ~ Normal string here that you Intended to Keep\"</code></p>\n<p>For this purpose, libtool also has its own wrapper on <code class=\"language-text\">sed</code> named\n<code class=\"language-text\">$SED</code> that can be used in the strings. During build this will be converted\ninto a runnable <code class=\"language-text\">sed</code> command. <code class=\"language-text\">$SED</code> is same as <code class=\"language-text\">sed</code>, except it uses <code class=\"language-text\">|</code> in place of <code class=\"language-text\">/</code>.</p>\n<p>So the final implementation becomes something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">_LT_TAGVAR(archive_expsym_cmds, $1)='$SED \"s|^|_|\" $export_symbols >$output_objdir/$soname.expsym~$CC -sSIDE_MODULE=2 -shared $libobjs $deplibs $compiler_flags -o $lib -s EXPORTED_FUNCTIONS=@$output_objdir/$soname.expsy</code></pre></div>\n<p>To break down:</p>\n<ul>\n<li>We take the input file with <code class=\"language-text\">$export_symbols</code></li>\n<li>We use sed to add _ before every function name:\n<code class=\"language-text\">$SED \"s|^|_|\" $export_symbols</code></li>\n<li>We save it to <code class=\"language-text\">$output_objdir/$soname.expsym\"</code></li>\n<li>We preceed it with the ~ to indicate that command part has ended, its time to take the actual string.</li>\n<li>In the string, we can use <code class=\"language-text\">$output_objdir/$soname.expsym</code> instead of</li>\n</ul>\n<p><code class=\"language-text\">$export_symbols</code>!</p>\n<p>You may ask here, we have already handled -shared in archive_cmds. So why\nhandle it here again? The answer is: If a file has functions to export,\nLibtool will use archive_expsym_cmds, otherwise, Libtool will use\narchive_cmds.</p>\n<p>And with this, our libtool is ready for emscripten. We just create a\npatch out of it, and instruct our emscripten  build script to always\napply our patch and compile libtool in case of shared compilation.</p>\n<p>Also it turns out that several features of emscripten are not quite\nready yet for this purpose. For example, EM_JS is not supported\nin emscripten shared modules. EM_JS is a macro that allows one to\nexecute JavaScript inside web assembly. Also there are issues with\nlinker in emscripten linker for compiling C++ sources with shared\nmodules. Finally, emscripten's implementation of opendir only works\nwith WasmFS. WasmFS is a virtual filesystem for file operations\nprovided by emscripten. WasmFS is not linked with the server, so\nactual directory search is not conducted by opendir.</p>\n<p>To mitigate this, I added a JavaScript method that mounts the plugin\ndirectory to WasmFS. After that libvlc_new is initiated and module\nloading begins.</p>","frontmatter":{"title":"Google Summer of Code - My work At VideoLAN","date":"August 26, 2023","description":"Google Summer of Code Work Details"}},"previous":{"fields":{"slug":"/libtool/gsoc-libtool-part1/"},"frontmatter":{"title":"Google Summer of Code Journey:  Hacking Libtool: Part 1"}},"next":null},"pageContext":{"id":"e8efab9e-25aa-522b-aadb-0cda46cf09b7","previousPostId":"721092cc-20e6-557b-8f96-991d284612b4","nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}