{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/gsoc-libtool-part1/","result":{"data":{"site":{"siteMetadata":{"title":"Labnan's Blog"}},"markdownRemark":{"id":"da50a058-ea12-5744-93e7-e30417ae2a0b","excerpt":"While working in VLC.js for VideoLAN in Google Summer of Code 2023, I came\naccross an interesting problem. You see VLC uses GNU Autotools to\ncreate theirâ€¦","html":"<p>While working in VLC.js for VideoLAN in Google Summer of Code 2023, I came\naccross an interesting problem. You see VLC uses GNU Autotools to\ncreate their compilation script, like most other C/C++ projects. The\ncompilation process is simple, if all dependencies are installed.</p>\n<p>First you bootstrap with ./bootstrap\nThen you configure, with ./configure [--enable-params] [--disable-params]\n[other params]\nAnd finally you compile, using GNU/Make, with the command 'make'.</p>\n<p>In the configure step, among various enable/disable parameters, there\nis one parameter called \"shared\". This allows the modules to be compiled\nas dynamic libraries, making them dynamic linkable.</p>\n<p>So, to enable dynamic linking for wasm32-unknown-emscripten I had to just\ndo this one thing: add --enable-shared to the configure parameters,\nright?</p>\n<p>Wrong! Turns out even if we use --enable-shared in case of wasm32-unknown-emscripten\nit does static compilation! I first realized this when I tried\n--enable-vlc with --enable-shared just to see how it turns out. And\nthe configuration fails with the error:\n\"VLC is based on plugins. Shared libraries cannot be disabled.\"</p>\n<p>Something is wrong! This is not supposed to happen, I have tried with\nx86_64-linux host, and it works perfectly, then why not in case of\nemscripten? For some reason, shared libraries can not be enabled!\nTime for some investigation.</p>\n<h4>What and why wasm32-unknown-emscripten?</h4>\n<p>For that, you have to know what cross compilation triplet is. Briefly saying,\nit is &#x3C;Architecture>-&#x3C;Vendor>-&#x3C;Operating System>, so here wasm32 is the\narchitecture here, emscripten is the Operating System taken to be running\non the browser. VLC.js is basically vlc media player ported to web assembly,\nrunning with Emscripten in browser, hence we use this.</p>\n<p>So, the first thing I did was enable building of vlc binaries,  with\n--enable-vlc, as vlc binaries can not be built without dynamic loading\nenabled. There has to be a check there, that makes sure that shared\nmodules are enabled.  Opening the configure script and searching for\n\"VLC is based on plugins\", we indeed find the condition there:</p>\n<p>if test \"${enable_shared}\" = \"no\" -a \"${enable_vlc}\" != \"no\"</p>\n<p>So, something must have caused enable_shared to be no, But what is it?</p>\n<p>Something must have assigned enable_shared to be no, so let's search\nfor \"enable_shared=no\", and just few lines before the above line, we\nfind that:</p>\n<p>test no = \"$can_build_shared\" &#x26;&#x26; enable_shared=no</p>\n<p>So, the value of enable_shared came from can_build_shared, so now we\nsearch for \"can_build_shared=no\" to find out that its value came from\nthe variable dynamic_linker. And it turns out the value of dynamic_linker\nis pre-assigned based on host_os. For example, if host_os is android,\ndynamic linker is \"Android linker\" and so on. There seemed to be only\none purpose of this variable, that is to indicate whether a dynamic linker\nexists for that particular host_os. Which does not exist for the host_os\nI am targetting, \"emscripten\".</p>\n<p>But the name, \"Android linker\" for android has to come from somewhere.\nThe configure script itself is generated from various configure.am files\nwhen running the bootstrap script as mentioned earlier. So, I make a quick search:</p>\n<p>git grep -r \"Android linker\"</p>\n<p>Only to find nothing. So this value does not exist in the repository as\na configuration file or anything, rather the value came from outside the\nrepository. My mentor Alexandre Janniaux was very helpful to point out\nthat the value comes from libtool, and what we can do at this point is to\nhack libtool and add dynamic_linker for emscripten at libtool/m4/libtool.m4\nand use that custom libtool.</p>\n<p>And in libtool.m4 there it was, the \"Android linker\" for the host\nlinux*android. Taking inspiration from how android section was implemented,\nwe added a new host_os named emscripten, with dynamic_linker to be\n\"Emscripten linker\", and bingo! After rebootstrapping with the new libtool\nthe configuration script ran successfully without switching to static mode\nsilently.</p>\n<h4>What is libttool?</h4>\n<p>Libtool is a generic library support script that hides the complexity of\nusing shared libraries behind a consistent, portable interface. Different\ncompilers take different flags, commands or approaches to compile shared\nlibraries. Therefore compiler front end becomes inconsistent. Which in terms,\nforces us to use too many unnecessary conditionals in Makefiles. To fix\nthis issue, Libtool was developed, it handles the differences internally\nwhile giving a consistent front end that we can use for the Makefiles,\nenabling us to compile for any other targets whenever needed.</p>\n<p>Later, we configured emscripten host in libtool to make compilation\ncompatible with various features in Emscripten compiler that is different\nfrom Clang or GCC. The details will be in part two!</p>\n<p>In this article we learned and reviewed:</p>\n<ul>\n<li>How projects are typically compiled and built and a bit of inner\nmechanisms.</li>\n<li>Debugging build scripts.</li>\n<li>How to get started with adding a new host target to libtool.</li>\n</ul>\n<p>Stay tuned for the part two! And stay safe.</p>","frontmatter":{"title":"Google Summer of Code Journey:  Hacking Libtool: Part 1","date":"August 15, 2023","description":"Hacking Libtool - Part 1, why hack Libtool?"}},"previous":{"fields":{"slug":"/blog/my-experience2/"},"frontmatter":{"title":"Linux Kernel Bug Fixing - My Experience"}},"next":{"fields":{"slug":"/gsoc/my-work-in-gsoc-at-videolan/"},"frontmatter":{"title":"Google Summer of Code - My work At VideoLan"}}},"pageContext":{"id":"da50a058-ea12-5744-93e7-e30417ae2a0b","previousPostId":"5b78d382-12d0-5fa0-be5f-b13020426e58","nextPostId":"e8efab9e-25aa-522b-aadb-0cda46cf09b7"}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}